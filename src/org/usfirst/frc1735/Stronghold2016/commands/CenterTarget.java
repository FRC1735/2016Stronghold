// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.Stronghold2016.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.networktables.NetworkTable;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc1735.Stronghold2016.Robot;

/**
 *
 */
public class CenterTarget extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public CenterTarget() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
    }

    // Called just before this Command runs the first time
    protected void initialize() {
    	// While ideally the setpoint would result in a target at 0,0
    	// (we use a scaled Xpos value ranging from -1 at left edge and +1 at right edge)
    	// The reality is that the camera is off-center and we might need a non-zero setpoint
    	// in order to REALLY center on the target.  So, pull the value from the SmartDashboard
    	// so that we can tune the final value.
    	double targetSetpoint = SmartDashboard.getNumber("TargetSetpoint");
    	Robot.pIDVisionDrivetrain.setSetpoint(targetSetpoint);// centered target is ideally a setpoint of 0 (range -1 to +1)
    	Robot.pIDVisionDrivetrain.enable(); // Enable the PID!
    	
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    	// Get the current target center value from the vision subsystem, and turn the robot such that
    	//  the target is centered in the view.
    	// Note:  This might just call the PIDSubsystem's setpoint/enable.
    	// but... if we have to implement our own it would be done as follows...
    	
     	// General heuristic:  Implement a simple PID controller that uses only P.
    	// 1a) Get the current list of targets found.  There might be more than one visible at a time
    	// 1b) Choose the one that has the largest area.  This is PROBABLY the closest target (and most in-line)
    	//    Don't want to choose the one closest to the center because that might actually be the target
    	//    for a different face that's very oblique to our robot position.
    	double xPosition = Robot.vision.getScaledTargetXpos();
    	SmartDashboard.putNumber("TargetXPos", xPosition);
    	
     	//
    	// 3) If centered within a reasonable "tolerance", stop the motors (Make this the isFinished() check)
    	// 4) Turn the robot in the same direction at a magnitude proportional to the "error".  This is the P term for a PID controller.
    	//    Because we normalized everything to +1/-1, we can use the error exactly as our P term and apply it directly to the motors...
    	
    	//
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
    	return Robot.pIDVisionDrivetrain.onTarget();
    }

    // Called once after isFinished returns true
    protected void end() {
    	Robot.pIDVisionDrivetrain.disable(); // turn off the PID!
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	end();
    }
}

// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.Stronghold2016.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.CommandGroup;
import org.usfirst.frc1735.Stronghold2016.subsystems.*;

/**
 *
 */
public class AutonomousCenterAndShoot extends CommandGroup {


    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PARAMETERS
    public AutonomousCenterAndShoot() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PARAMETERS
        // Add Commands here:
        // e.g. addSequential(new Command1());
        //      addSequential(new Command2());
        // these will run in order.

        // To run multiple commands at the same time,
        // use addParallel()
        // e.g. addParallel(new Command1());
        //      addSequential(new Command2());
        // Command1 and Command2 will run in parallel.

        // A command group will require all of the subsystems that each member
        // would require.
        // e.g. if Command1 requires chassis, and Command2 requires arm,
        // a CommandGroup containing them would require both the chassis and the
        // arm.
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=COMMAND_DECLARATIONS
    	// Initial state:  facing backwards directly in front of Low Bar defense
    	// 1) Deploy the collector so we can go under the lowbar (backwards)
    	// But can't do that first thing because we will cross the midline and get a tech foul.
    	// So, drive forward for a moment to clear the line, then in parallel wait a half second and then deploy collector

    	// Copy from lower-and-cross:
    	addSequential(new DriveWithLimits(1000, 0.5, -0.75)); // distance, time, mag
    	addSequential(new DeployCollector(.5), 0.25); // second arg to addSequential is an optional timeout in seconds

     	// 1) Drive backwards long enough to get over low bar
        addSequential(new DriveWithLimits(13.9-2.5, 5, -0.75, false, false));// PRe-RI, was 16.9-2.5coast
        //addSequential(new Delay(0.5));
        //addSequential(new DeployCollector(.5), 0.25); // second arg to addSequential is an optional timeout in seconds
        
        // We want the parallel process to finish before doing this next step
        //addSequential(new WaitForChildren()); // Won't return until all previous parallel commands have completed.
        
        // Turn compensation to avoid hitting the wall
        //addSequential(new Turn(+7));
        //addSequential(new Delay(0.5));
        
        // Now continue with the rest of the driving
        Command cmd = new DriveWithLimits(8.75, 2, -0.5); // drive to X' from obstacle (using override below!)
        DriveWithLimits driveCmd = (DriveWithLimits)cmd; // cast command to implemented type so we an access variables
        driveCmd.m_useDistanceFromObstacle = true; // override the default for this one instance of the command
        addSequential(driveCmd);
        
        // MOTION
        // 2) turn mostly around so that we are (roughly) facing the goal
        addSequential(new Turn(-160));
 
        //EVENTUALLY.. The full automated sequence will done by this comandGroup:
        //addSequential(new AutoCenterAndShootSequence());

        // This is the full sequence done manually without full calculations...
        // CENTERING
        // 3) center on the target... hopefully
        //addSequential(new CameraLight(true));
        addSequential (new CenterTargetDouble()); // Turns lights on/off
        //addSequential(new CameraLight(false));

        //SHOOTING
        // 4) start the shooter
        addParallel (new ShooterStart()); // Gets RPMs from precompiled value in Robot.java
        // 5) Let the shooter get up to speed (someday the PID will do this and the delay won't be needed)
        addSequential (new Delay(2));
        // 6) Advance the ball into the shooter for 1 second
        addParallel (new LoadShooter(-1)); // arg is magnitude (negative here is towards the shooter
        addSequential (new Delay(1));
        // 7) Foomp.  Ball is gone, so stop the shooter and the loader.
        addSequential (new ShooterStop());
        addSequential (new FeederStop());

        
        // We're done.
 
    } 
}

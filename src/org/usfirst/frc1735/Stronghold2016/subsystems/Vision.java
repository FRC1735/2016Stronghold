// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.Stronghold2016.subsystems;

import org.usfirst.frc1735.Stronghold2016.RobotMap;
import org.usfirst.frc1735.Stronghold2016.commands.*;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.networktables.NetworkTable;


/**
 *
 */
public class Vision extends Subsystem {
	NetworkTable table;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// create a new constructor
	public Vision() {		
    // Get a pointer to the networkTable
    table = NetworkTable.getTable("Grip/StrongholdContours");
	}
    


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public double getTargetXpos() {
    	// 1) Get the current list of targets found.  There might be more than one visible at a time
       	// first, get the vision system data for the target
    	double[] defaultValue = new double[0]; // set up a default value in case the table isn't published yet
    	double[] targetX = table.getNumberArray("centerX", defaultValue);
    	
    	// For initial debug, just print out the table so we can see what's going on
    	System.out.print("centerX: ");
    	for (double xval : targetX) { // for each target found,
    		System.out.print(xval + " ");
    	}
    	System.out.println();
    	
    	
    	// 2) Choose the one that has the largest area.  This is PROBABLY the closest target (and most in-line)
    	//    Don't want to choose the one closest to the center because that might actually be the target
    	//    for a different face that's very oblique to our robot position.
    	return 160; // return the centered value for the moment so nothing blows up
    }
    
}


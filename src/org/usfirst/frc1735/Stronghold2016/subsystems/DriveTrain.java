// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc1735.Stronghold2016.subsystems;

import java.util.ArrayList;
import java.util.List;

import org.usfirst.frc1735.Stronghold2016.Robot;
import org.usfirst.frc1735.Stronghold2016.RobotMap;
import org.usfirst.frc1735.Stronghold2016.commands.*;

import edu.wpi.first.wpilibj.AnalogInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController leftMotor = RobotMap.driveTrainLeftMotor;
    private final SpeedController rightMotor = RobotMap.driveTrainRightMotor;
    private final RobotDrive robotDrive21 = RobotMap.driveTrainRobotDrive21;
    private final Encoder leftMotorEncoder = RobotMap.driveTrainLeftMotorEncoder;
    private final Encoder rightMotorEncoder = RobotMap.driveTrainRightMotorEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // Add a constructor to initialize the joystick history
    public DriveTrain () {
    	m_joyLeftHistory = new ArrayList<>();
    	m_joyRightHistory = new ArrayList<>();
    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new DriveWithJoysticks());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    // This is just a wrapper so the joystick and direct methods live in the same class for consistency.
    public void tankDriveWithJoysticks(Joystick left, Joystick right) {
        // Collect the Joystick info.
        // We need to filter out very small joystick values and clamp them to zero
        // so that a slightly off-center joystick doesn't send signals to the motor.
        double driveLeft = left.getY();
        double driveRight = right.getY();
        
        //Apply Filter
        if (Math.abs(driveLeft) < Robot.m_joystickFilter) {driveLeft = 0;}
        if (Math.abs(driveRight) < Robot.m_joystickFilter) {driveRight = 0;}

        // Apply selective proportional reduction.
        // Unless the Driver right Button2 is pressed, reduce speed by 25%
        if (false/*!Robot.oi.turboMode.get()*/) {
        	driveLeft = driveLeft * 0.80; // FWIW, the 2015 robot ran at 66%
        	driveRight = driveRight * 0.80;
        }
       
        
        //We may need to drive the robot BACKWARDS from the joysticks on a frequent basis.
        // Add a button that allows us to reverse what is the "Front" of the robot to make this easier...
        // (Button defined in oi.java)
        if (Robot.oi.reverseDrive.get()) {
        	// if reverseDrive is set, we want to reverse the "front" of the robot.
        	// This means that pushing forward should move the robot backwards.
        	// This basically means that we reverse the polarity of the Y axis of the joystick.
        	// drive inverted (negative Y means "down" on the joystick)
        	// You also have to reverse Right and Left...
        	this.tankDrive(driveRight, driveLeft);
        }
        else {
        	// Drive normally (negative Y means "up" on the joystick).
        	this.tankDrive(-driveLeft, -driveRight);
        	
        }
        
        // for debug, print the ball banner sensor value here
        //SmartDashboard.putBoolean("Ball Detect", RobotMap.feederBallReady.get());
    }
       
    public void tankDrive(double driveLeft,double driveRight) {
    	// Note that motorCompensation is done in DriveWithLimits, rather than here...
    	// it *could* be moved back here if we needed some kind of teleoperated assist for
    	// driving straight.  (e.g. another modifier button that reads only one joystick and
    	// uses motorCompensation to drive perfectly straight at the desired speed)
    	
        // Apply smoothing
        // ---------------
    	// Because we need to modify the drive magnitude AND update the history,
    	// and because we can't modify args (which are passed by reference),
    	// and because it's very clunky to return multiple values that are of different types,
    	// we pass in a flag to the routine as to which History we are modifying, and then let the routine
    	// internally modify the History.
    	// Yeah, it's not elegant.
        driveLeft  = applyInputSmoothing(driveLeft,  DriveSides.DRVLEFT);
        driveRight = applyInputSmoothing(driveRight, DriveSides.DRVRIGHT);
        
        robotDrive21.tankDrive(driveLeft, driveRight); // Optional third arg bool SquaredInputs, when true, decreases sensitivity at low speeds.
    }

    // Function to STOP the drivetrain:
    public void stop() {
    	robotDrive21.tankDrive(0, 0); //left, right
    }
    
    // In order to reduce acceleration and "Wheelies" without limiting the top speed of the robot,
    // We need to apply some smoothing on the joystick inputs so that we don't apply too much motor
    // output delta per unit time
    private double overlyComplicated_applyInputSmoothing(double driveVal, DriveSides driveSide) {
    	double smoothedDriveVal = driveVal; // Assume no change to the value
    	// Because it's easiest to modify the History variables directly rather than deal with
    	// multiple return values of different types, use the arg enum to grab the correct variable for
    	// manipulations
    	List <Double> joyHistory;
    	switch (driveSide) {
    	case DRVLEFT:
    		joyHistory = m_joyLeftHistory;
    		break;
    	case DRVRIGHT:
    		joyHistory = m_joyRightHistory;
    		break;
    	default:
    		System.out.println("Error:  illegal enum passed to applyInputSmoothing: " + driveSide);
    		joyHistory = new ArrayList<>(); // create something so that the IDE parser is happy
    		break;
    	}
    	
    	// Remove the oldest item in the joyHistory (if it exists)
    	if (joyHistory.size() > 0)
    		joyHistory.remove(0);
    	// (temporarily) add the new requested value.  we may replace this at the end of the function w/ the final value.
    	joyHistory.add(driveVal);
    	
    	// find the average delta between samples.  This is the effectively the requested acceleration.
    	// -------------
    	//FIXME:  This doesn't handle the first iteration where there is only ONE value in the List.
    	double currentDelta = 0;
    	double totalDelta = 0;
    	// Iterate over the last N samples to get the average delta
    	// hard to use an Iterator since we might be starting partway through the list.  For loop is easier
    	int historyDepth = Math.min(m_historyDepth, joyHistory.size());
    	int startIdx = joyHistory.size()- historyDepth;
    	int endIdx = Math.max(startIdx, joyHistory.size()-1);

    	// Start at +1 so we always have a previous val to check
    	for (int i = startIdx+1; i<=endIdx; i++) {
    			// need previous value for the delta, so we start 
    			currentDelta = joyHistory.get(i) - joyHistory.get(i-1);
    			totalDelta += currentDelta;
    	}
    	double avgDelta = totalDelta / Math.min((joyHistory.size()-startIdx-1),1); // avoid div by zero

    	
    	// If the acceleration is now greater than a predefined "Acceleration limit", then
    	// Reduce the driveVal by squaring the input value.
    	// (Since inputs are -1 to +1, this won't blow up)
    	if (Math.abs(avgDelta) > m_maxAccel) {
    		smoothedDriveVal = driveVal *  driveVal;
    		// Update the value in the list
    		joyHistory.set((joyHistory.size()-1), smoothedDriveVal);
    	}
    	// TODO:  Even squared, we might be exceeding the max accel.
    	//        Might need to wrap in a while() loop to square multiple times...?
    	return smoothedDriveVal;
    }

    // Let's try something that doesn't require complicated averaging and derivatives!
    // Just limit the instantaneous delta between now and the previous joystick value to a max value.
    private double applyInputSmoothing(double driveVal, DriveSides driveSide) {
    	double smoothedDriveVal = driveVal; // Assume no change to the value
    	// Because it's easiest to modify the History variables directly rather than deal with
    	// multiple return values of different types, use the arg enum to grab the correct variable for
    	// manipulations
    	List <Double> joyHistory;
    	switch (driveSide) {
    	case DRVLEFT:
    		joyHistory = m_joyLeftHistory;
    		break;
    	case DRVRIGHT:
    		joyHistory = m_joyRightHistory;
    		break;
    	default:
    		System.out.println("Error:  illegal enum passed to applyInputSmoothing: " + driveSide);
    		joyHistory = new ArrayList<>(); // create something so that the IDE parser is happy
    		break;
    	}
    	
    	// Remove the oldest item in the joyHistory (if it exists)
    	while (joyHistory.size() > 10) // Save ten items.  At 20ms polling period, that's 200ms of data.
    		joyHistory.remove(0);
    	
    	// Get the delta from the previous value
    	double deltaVal;
    	if (joyHistory.size() > 0) // If there *is* a previous value
    		deltaVal = driveVal - joyHistory.get(joyHistory.size()-1);
    	else
    		// Not enough history.  Treat "previous" as zero, and use current value as the delta.
    		deltaVal = driveVal;
    	
    	// is this delta larger than the max allowed?
    	double overage = Math.abs(deltaVal) - m_maxAccel;
    	if (overage > 0) {
    		// If we are over the max acceleration, we have to compensate.
    		// Remember, we have to deal with sign of the delta, too. (and the fact that output range is -1 to +1)
    		//     if the delta is >0 then we increased too much and need to subtract the overage.
    		//     if the delta is <0 then we decreased too much and need to add the overage.
    		smoothedDriveVal = (deltaVal > 0) ? (driveVal - overage) : (driveVal + overage); 
        	System.out.println("Drivetrain input for " + driveSide.toString() + "was " + driveVal + "; smoothing this to " + smoothedDriveVal);
    	}
    	joyHistory.add(smoothedDriveVal);
    	return smoothedDriveVal;
    }
    
    // Member variables
    public double m_wheelDistancePerRobotRevolution = 7.46269; // How far does the encoded wheel travel for one robot revolution?  Empirically determined.
    private List<Double> m_joyLeftHistory;  // Holds a history of previous left joystick values
    private List<Double> m_joyRightHistory; // Holds a history of previous right joystick values
    public enum DriveSides {DRVLEFT, DRVRIGHT}; // Use enum rather than strings to reduce programmer "pilot error"
    private int m_historyDepth = 1; // How many prior values to average for the delta
    // Assume we take about 0.6 sec to get to full speed (1.0) from dead stop (0.0).
    // at 20ms polling period (50 ticks/sec), that is about 30 ticks.  Each tick is therefore 1/30 of max change = .033333
    private double m_maxAccel = 0.03333;
}

